# Banned API Analyzer 導入・運用事例サンプル

## このリポジトリについて

本リポジトリは、チーム開発におけるコード品質の均一化と、プロジェクト固有ルールの遵守を自動化するために導入した **`Microsoft.CodeAnalysis.BannedApiAnalyzers`** の活用事例です。

実際の開発現場で直面した「スキルレベル差による品質のばらつき」や「レビューコストの増大」といった課題に対し、静的解析を用いてどのように解決したかをコードと共に示します。

## 導入前のチーム状況と課題

私が所属していたプロジェクトでは、以下のような課題を抱えていました。

- チーム構成の多様性
    - ジュニアからシニアまでスキルレベルが異なるエンジニアが混在しており、コードの品質にばらつきが生じていた。
- 「動くけど非推奨」なコードの混入
    - テストが困難な実装（`DateTime.Now` の直接利用など）や、本番環境で不適切な実装（`Console.WriteLine` など）が散見された。
- コードレビューの形骸化とコスト増
    - 「ここは `DateTime` を直接使わないでください」といった定型的な指摘が繰り返され、レビュアーのリソースが本質的な設計レビュー以外に割かれていた。
- ルールの強制力不足
    - Wikiや口頭でのルール共有では限界があり、プロジェクト固有の規約（アーキテクチャルールなど）を徹底することが難しかった。

## なぜ既存のツールでは不十分だったか

EditorConfig や標準の静的解析ツール（Roslyn Analyzers）でも一般的な品質管理は可能ですが、本プロジェクト特有の課題解決には限界がありました。

- 「文脈依存」のルールを強制できない
    - `DateTime.Now` や `Console.WriteLine` は言語仕様として正しいコードであり、一般的なリンターでは警告されません。「このプロジェクトのテスト戦略上、使用を禁止したい」といったプロジェクト固有の文脈を反映させる必要がありました。
- 「代替案」を提示できない
    - 既存ツールで無理やり禁止しても、「なぜダメなのか」「代わりに何を使えばいいのか」までは開発者に伝わりません。エラーメッセージを通じて具体的な解決策を提示する仕組みが必要でした。

## 導入した仕組みと工夫

これらの課題を解決するために、静的解析ツール **`Microsoft.CodeAnalysis.BannedApiAnalyzers`** を導入し、「ルールを破るとビルドが通らない」仕組みを構築しました。

### 運用のポイント

1.  「後で直す」を許さないためのエラー化
    - 警告のままでは無視されてしまうことが多かったため、CI で確実に弾くためにエラーとして扱いました。
2.  「なぜダメなのか」をその場で伝える
    - 単に禁止するだけでなく、Analyzer のメッセージ機能を使って「なぜ禁止なのか」「代わりに何を使うべきか」を明示し、開発者が迷わないように配慮しました。

## 実際に運用した禁止ルール

本サンプルプロジェクトでは、実際に運用していた以下のルールを再現しています。

### Case 1: テストしやすくするためのルール

ユニットテストにおいて現在時刻やランダム値に依存するコードは、再現性を損なう原因となります。

- [NG] 禁止
    - `System.DateTime.Now`, `System.DateTime.UtcNow`
- [OK] 推奨
    - `TimeProvider` クラス (.NET 8+)
- **表示されるエラーメッセージ**
    > `System.DateTime.Now` is banned in this project: 現在時刻に依存する処理はテストが困難になるため、TimeProvider を使用してください。

### Case 2: ログを正しく残すためのルール

コンソール出力はクラウド環境やサーバー環境ではログとして適切に収集されない場合があり、構造化ログへの移行が必要でした。

- [NG] 禁止
    - `System.Console.WriteLine`, `System.Console.Write`
- [OK] 推奨
    - `Microsoft.Extensions.Logging.ILogger`
- **表示されるエラーメッセージ**
    > `System.Console.WriteLine` is banned in this project: コンソール出力はログ基盤に収集されない可能性があるため、ILogger を使用してください。

### Case 3: パフォーマンス低下を防ぐルール

スケーラビリティを確保するため、I/O処理における同期メソッドの使用を禁止しました。

- [NG] 禁止
    - `System.IO.File.ReadAllText` などの同期API
- [OK] 推奨
    - `ReadAllTextAsync` などの非同期API
- **表示されるエラーメッセージ**
    > `System.IO.File.ReadAllText` is banned in this project: スレッドプールの枯渇を防ぐため、I/O処理には非同期メソッドを使用してください。

## 導入後のチームの変化

この仕組みを導入した結果、以下の効果が得られました。

- レビューコストの削減
    - 定型的な指摘が自動化され、人間は設計やビジネスロジックの議論に集中できるようになった。
- オンボーディングの効率化
    - 新規参画メンバーがコードを書く際、IDE上でリアルタイムに規約違反を知ることができるため、自然とプロジェクトのルールを学習できた。
- 品質の均一化
    - メンバーのスキルレベルに関わらず、一定のコード品質（テスト容易性など）が強制的に担保されるようになった。

## プロジェクト構成

（今後サンプルコードを追加予定）
